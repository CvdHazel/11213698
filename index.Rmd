---
title: "Portfolio Computational Musicology"
author: "Chayenne van den Hazel"
date: "3 maart 2019"
output: 
    flexdashboard::flex_dashboard:
        storyboard: true
        theme: lumen
---

```{r}
library(tidyverse)
library(spotifyr)
library(plotly)
Sys.setenv(SPOTIFY_CLIENT_ID = '9770ee77431949d080fdc8a169bb3899')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '80492b1686844994a7ffd6bca1782363')
```

### What is this storyboard about? 

The rock/metal band Bring Me The Horizon released their sixth album *amo* on the 25th of January 2019. The reaction on the new album is divided. The sound of this album is totally different than fans are used to hearing from them. It feels like they are stepping out of their 'heavy metal' image and taking on a new one. One song called 'heavy metal' of Bring Me The Horizon's new album talks about their change in genre and the reaction of their fans:

*"And I keep picking petals
I'm afraid you don't love me anymore
'Cause a kid on the 'gram in a Black Dahlia tank
Says it ain't heavy metal"*

I want to know if their new album is really that different from the other albums and what the difference is exactly. Is it true that they are changing their image and what are they changing it to? My research question is therefore: Is Bring Me The Horizon creating a new musical image and what is this image exactly?

To anwer my research question I'm using a handfull of different Spofity playlists to compare their features. My main corpus is obviously Bring Me The Horizon's newest album *amo*. Besides that I'm also looking into all their old albums: *Count Your Blessings*, *Suidice Season*, *There is a Hell Believe Me I've Seen it. There is a Heaven Let's Keep it a Secret*, *Sempiternal* and *That's the Spirit*. To get the Spotify features for the albums, I've make seperate playlist for each. With the help of these albums I can compare the new album to their old ones and see if there are differences and similarities. I'm not only doing this between albums, but also with genres. I'm using different Spotify playlists to compare them to the albums and see which genre fits the best per album. The playlist I'm using for this are: Rock Classics, Pure Pop Punk, Heavy Metal, Pop Internacional and Ultimate Indie. By using the Bring Me The Horizon albums and the genre playlist, I hope to answer my research question 


### Is Bring Me The Horizon's newest album really that different from their first album?

```{r}
# Data Spotify features 

blessings <- get_playlist_audio_features('faaske', '3q4J2ymyPxuRH49FUexRDA')
amo <- get_playlist_audio_features('faaske', '1GEk4D55A3EI7uKAcr1N0w')
bmth <- get_artist_audio_features('Bring Me The Horizon')

# Combine data sets

albums <-
    blessings %>% mutate(album = "Count your blessings") %>%
    bind_rows(amo %>% mutate(album = "amo"))

#Plot valence/energy first and last ablum 

ve_album<- albums %>%                       # Start with awards.
    ggplot(                      # Set up the plot.
        aes(
            x = valence,
            y = energy,
            size = danceability,
            colour = mode
        )
    ) +
    geom_point(alpha = 0.8) +               # Scatter plot.
    geom_rug(size = 0.1) +       # Add 'fringes' to show data distribution.
    facet_wrap(~ album) +     # Separate charts per playlist.
    scale_x_continuous(          # Fine-tune the x axis.
        limits = c(0, 1),
        breaks = c(0, 0.50, 1),  # Use grid-lines for quadrants only.
        minor_breaks = NULL      # Remove 'minor' grid-lines.
    ) +
    scale_y_continuous(          # Fine-tune the y axis in the same way.
        limits = c(0, 1),
        breaks = c(0, 0.50, 1),
        minor_breaks = NULL
    ) +
    scale_colour_brewer(         # Use the Color Brewer to choose a palette.
        type = "qual",           # Qualitative set.
        palette = "Paired"       # Name of the palette is 'Paired'.
    ) +
    scale_size_continuous(       # Fine-tune the sizes of each point.
        trans = "exp",           # Use an exp transformation to emphasise loud.
        guide = "none"           # Remove the legend for size.
    ) +
    theme_light() +              # Use a simpler them.
    labs(                        # Make the titles nice.
        x = "Valence",
        y = "Energy",
        colour = "Mode"
    )

ggplotly(ve_album)

```

***

In this graph, the Spotify features 'Valence' and 'Energy' are plotted against eachother for Bring Me The Horizon's first (*Count your Blessings*) and latest album (*amo*). Both albums score low on valence, but really high on energy. In general, *amo* scores higher on valence than *Count your Blessings*. Both albums have an outlier with a lower energy level than the rest of the songs. The size of the dots show the danceability of the songs. The songs on *amo* are in general more 'danceable' than the songs on *Count your Blessings*. 

### Does 'heavy metal' sound like Heavy Metal?

```{r}

#' Loads the Spotify audio analysis for a track without extra
get_tidy_audio_analysis <- function(track_uri, ...)
{
    get_track_audio_analysis(track_uri, ...) %>%
        list %>% transpose %>% as_tibble %>%
        mutate_at(vars(meta, track), . %>% map(as_tibble)) %>%
        unnest(meta, track) %>%
        select(
            analyzer_version,
            duration,
            contains('fade'),
            ends_with('confidence'),
            bars:segments) %>%
        mutate_at(
            vars(bars, beats, tatums, sections),
            . %>% map(bind_rows)) %>%
        mutate(
            segments =
                map(
                    segments,
                    . %>%
                        transpose %>% as_tibble %>%
                        unnest(.preserve = c(pitches, timbre)) %>%
                        mutate(
                            pitches =
                                map(
                                    pitches,
                                    . %>%
                                        flatten_dbl %>%
                                        set_names(
                                            c(
                                                'C', 'C#|Db', 'D', 'D#|Eb',
                                                'E', 'F', 'F#|Gb', 'G',
                                                'G#|Ab', 'A', 'A#|Bb', 'B'))),
                            timbre =
                                map(
                                    timbre,
                                    . %>%
                                        flatten_dbl %>%
                                        set_names(
                                            c(
                                                'c01', 'c02', 'c03', 'c04',
                                                'c05', 'c06', 'c07', 'c08',
                                                'c09', 'c10', 'c11', 'c12'))))))
}

#----- NORMS AND DISTANCE FUNCTIONS -----#

#' Normalise vectors for Computational Musicology.
#'
#' We use a number of normalisation strategies in Computational Musicology.
#' This function brings them together into one place, along with common
#' alternative names.
compmus_normalise <- compmus_normalize <- function(v, method = 'euclidean')
{
    ## Supported functions

    harmonic  <- function(v) v * sum(1 / abs(v))
    manhattan <- function(v) v / sum(abs(v))
    euclidean <- function(v) v / sqrt(sum(v^2))
    chebyshev <- function(v) v / max(abs(v))
    clr       <- function(v) {lv <- log(v); lv - mean(lv)}

    ## Method aliases

    METHODS <-
        list(
            identity  = identity,
            id        = identity,
            harmonic  = harmonic,
            manhattan = manhattan,
            L1        = manhattan,
            euclidean = euclidean,
            L2        = euclidean,
            chebyshev = chebyshev,
            maximum   = chebyshev,
            aitchison = clr,
            clr       = clr)

    ## Function selection

    if (!is.na(i <- pmatch(method, names(METHODS))))
        METHODS[[i]](v)
    else
        stop('The method name is ambiguous or the method is unsupported.')
}

#' Compute pairwise distances for Computational Musicology in long format.
#'
#' We use a number of distance measures in Computational Musicology.
#' This function brings them together into one place, along with common
#' alternative names. It is designed for convenience, not speed.
compmus_long_distance <- function(xdat, ydat, feature, method = 'euclidean')
{

    feature <- enquo(feature)

    ## Supported functions

    manhattan <- function(x, y) sum(abs(x - y))
    euclidean <- function(x, y) sqrt(sum((x - y) ^ 2))
    chebyshev <- function(x, y) max(abs(x - y))
    pearson   <- function(x, y) 1 - cor(x, y)
    cosine    <- function(x, y)
    {
        1 - sum(compmus_normalise(x, 'euc') * compmus_normalise(y, 'euc'))
    }
    angular   <- function(x, y) 2 * acos(1 - cosine(x, y)) / pi
    aitchison <- function(x, y)
    {
        euclidean(compmus_normalise(x, 'clr'), compmus_normalise(y, 'clr'))
    }

    ## Method aliases

    METHODS <-
        list(
            manhattan   = manhattan,
            cityblock   = manhattan,
            taxicab     = manhattan,
            L1          = manhattan,
            totvar      = manhattan,
            euclidean   = euclidean,
            L2          = euclidean,
            chebyshev   = chebyshev,
            maximum     = chebyshev,
            pearson     = pearson,
            correlation = pearson,
            cosine      = cosine,
            angular     = angular,
            aitchison   = aitchison)

    ## Function selection

    if (!is.na(i <- pmatch(method, names(METHODS))))
        bind_cols(
            crossing(
                xdat %>% select(xstart = start, xduration = duration),
                ydat %>% select(ystart = start, yduration = duration)),
            xdat %>% select(x = !!feature) %>%
                crossing(ydat %>% select(y = !!feature)) %>%
                transmute(d = map2_dbl(x, y, METHODS[[i]])))
    else
        stop('The method name is ambiguous or the method is unsupported.')
}


compmus_self_similarity <- function(dat, feature, method = 'euclidean')
{
    feature <- enquo(feature)
    compmus_long_distance(dat, dat, !!feature, method)
}


#----- SUMMARIES -----#

#' Summarise vector-based features in list columns.
#'
#' Summarise vector-based featrues in list columns. Does not work with classical tidyverse grouping.
compmus_summarise <- compmus_summarize <- function(dat, feature, method = 'mean', norm = 'id')
{
    feature <- enquo(feature)

    ## Support functions
    ## TODO: Add geometric median and Chebyshev center.
    ## TODO: Search for minimum sum of angular distances in hyper-quadrant I.

    clr     <- function(v) {lv = log(v); lv - mean(lv)}
    softmax <- function(v) {exp(v) / sum(exp(v))}
    square  <- function(v) v^2
    not_max  <- function(v) v != max(v)

    ## Method aliases

    METHODS <-
        list(
            ## Central tendencies
            mean      = list( identity , mean , identity ),
            aitchison = list( clr      , mean , softmax  ),
            acenter   = list( clr      , mean , softmax  ),
            acentre   = list( clr      , mean , softmax  ),
            rms       = list( square   , mean , sqrt     ),
            max       = list( identity , max  , identity ),
            ## Dispersions
            sd        = list( identity , sd   , identity ),
            asd       = list( clr      , sd   , identity ),
            sdsq      = list( square   , sd   , identity ),
            varratio  = list( not_max  , mean , identity ))

    ## Function selection

    if (!is.na(i <- pmatch(method, names(METHODS))))
        dat %>%
        transmute(
            !!feature :=
                map(
                    !!feature,
                    . %>%
                        compmus_normalise(norm) %>%
                        (METHODS[[i]][[1]]) %>%
                        bind_rows)) %>%
        unnest(!!feature) %>%
        summarise_all(METHODS[[i]][[2]]) %>%
        map_dbl(1) %>%
        (METHODS[[i]][[3]])
    else
        stop('The method name is ambiguous or the method is unsupported.')
}

compmus_align_helper <- function(start0, duration0, inner)
{
    end0 <- start0 + duration0

    inner %>%
        filter(start < end0) %>%
        filter(
            pmin(end, end0) - pmax(start, start0) >=
                pmin(duration, duration0) / 2) %>%
        select(-end)
}

compmus_align_reduce <- function(outer, inner, name)
{
    outer %>%
        mutate(
            !!name :=
                map2(
                    start,
                    duration,
                    compmus_align_helper,
                    inner %>% mutate(end = start + duration)))
}

#' Aligns lower-level Spotify segmentations with higher-level segmentations.
#'
#' Returns a list column with tibbles of the lower-level segment for each higher-level segement.
compmus_align <- function(dat, outer, inner)
{
    outer <- enquo(outer)
    inner <- enquo(inner)

    mutate(
        dat,
        !!outer := map2(!!outer, !!inner, compmus_align_reduce, inner)) %>%
        select(-!!inner)
}


#----- UNWRAPPING CHROMA VECTORS -----#

#' Gathers chroma vectors into long format.
#'
#' Gathers chroma vectors into long format for Computational Musicology.
compmus_gather_chroma <- function(data)
{
    data %>%
        mutate(pitches = map(pitches, bind_rows)) %>% unnest(pitches) %>%
        gather('pitch_class', 'value', C:B) %>%
        mutate(pitch_class = fct_shift(factor(pitch_class), 3))
}

#' Gathers timbre vectors into long format.
#'
#' Gathers timbre vectors into long format for Computational Musicology.
compmus_gather_timbre <- function(data)
{
    data %>%
        mutate(timbre = map(timbre, bind_rows)) %>% unnest(timbre) %>%
        gather('basis', 'value', c01:c12)
}

```
```{r}

# chromogram heavy metal 

heavymetal_song <- 
    get_tidy_audio_analysis('6baGTtDakSNvUfW3FJd8yX') %>% 
    compmus_align(bars, segments) %>% 
    select(bars) %>% unnest(bars) %>% 
    mutate(
        pitches = 
            map(segments, 
                compmus_summarise, pitches, 
                method = 'rms', norm = 'euclidean')) %>% 
    mutate(
        timbre = 
            map(segments, 
                compmus_summarise, timbre, 
                method = 'mean'))

heavymetal_song %>% 
    compmus_gather_timbre %>% 
    ggplot(
        aes(
            x = start + duration / 2, 
            width = duration, 
            y = basis, 
            fill = value)) + 
    geom_tile() +
    labs(x = 'Time (s)', y = NULL, fill = 'Magnitude') +
    scale_fill_viridis_c(option = 'E') +
    theme_classic()

# Chromagram walk

walk_song <- 
    get_tidy_audio_analysis('7fcfNW0XxTWlwVlftzfDOR') %>% 
    compmus_align(bars, segments) %>% 
    select(bars) %>% unnest(bars) %>% 
    mutate(
        pitches = 
            map(segments, 
                compmus_summarise, pitches, 
                method = 'rms', norm = 'euclidean')) %>% 
    mutate(
        timbre = 
            map(segments, 
                compmus_summarise, timbre, 
                method = 'mean'))

walk_song %>% 
    compmus_gather_timbre %>% 
    ggplot(
        aes(
            x = start + duration / 2, 
            width = duration, 
            y = basis, 
            fill = value)) + 
    geom_tile() +
    labs(x = 'Time (s)', y = NULL, fill = 'Magnitude') +
    scale_fill_viridis_c(option = 'E') +
    theme_classic()


```


***

Here you can see two chromagrams and the differences are immediately noticable. The first chromagram is of the song 'heavy metal' on Bring Me The Horizon's latest album *amo*. The second graph is a chromagram of the most popular song on Spotify's 'Heavy Metal' playlist 'Walk' by Pantara. Pantera is an American groovemetalband who are known as trendsetters in their genre in the nineties. 

### Does 'heavy metal' have the same structure as Heavy Metal?

```{r}

# heavy metal SSM
heavymetal_song %>% 
    compmus_self_similarity(timbre, 'cosine') %>% 
    ggplot(
        aes(
            x = xstart + xduration / 2, 
            width = xduration,
            y = ystart + yduration / 2,
            height = yduration,
            fill = d)) + 
    geom_tile() +
    coord_fixed() +
    scale_fill_viridis_c(option = 'E', guide = 'none') +
    theme_classic() +
    labs(x = '', y = '')
    
# walk SSM

walk_song %>% 
    compmus_self_similarity(timbre, 'cosine') %>% 
    ggplot(
        aes(
            x = xstart + xduration / 2, 
            width = xduration,
            y = ystart + yduration / 2,
            height = yduration,
            fill = d)) + 
    geom_tile() +
    coord_fixed() +
    scale_fill_viridis_c(option = 'E', guide = 'none') +
    theme_classic() +
    labs(x = '', y = '')
    
```

***

Before we looked at the chromagrams between 'heavy metal' by Bring Me The Horizon and 'walk' by Pantera. These graphs are Self-Similarity Martices based on timbre. Different than the chromagrams, here we don't see as much differences between the two songs. The horizontal and vertical yellow lines cross about the same time for both songs. 
